{"version":3,"sources":["webpack:///./src/modules/DM000003.js","webpack:///./src/utils/util.js"],"names":["DM000003","flips","canvas","SOL","SVG","p","g","callback","_flip","flip","flipG","addClass","uswerAnswer","first","undefined","firstItem","flipEndHandler","self","number","data","attr","pointerEvents","preventTouchRect","rect","opacity","isFrameEnd","every","el","wait","remove","center","position","cx","cy","randomColumn","getRandomNumber","point","getPointInMatrixForm","startPoint","x","y","rows","columns","gap","randomNumberArray","getRandomNumberArray","shffleCardNumber","shuffle","map","i","frontG","backG","circle","fill","text","toString","textAnchor","fontSize","front","back","clickable","click","drawFlipItem","getUniquArray","arr","filter","indexOf","get2dimArray","n","newArray","forEach","q","Math","floor","r","getTransposeArray","tempArr","push","length","reverse","offset","j","index","getPointInScatterForm","area","pointNum","neighborhood","points","isPointInsideBBox","bbox","abs","width","height","repeat","boundingBox","x2","y2","some","bbox2","bbox1","console","error","delay","Promise","resolve","setTimeout","getRandomArrayElement","slice","min","max","random","isUnique","randArr","uniqueArr","getSimultaneousEquationConstant","x1","y1","a","b","convertToPathStr","line","polygon","_rest","rest","Array","isArray","reduce","array","copyArray","k","isSameArray","calculateAnswer","num","sign","ans"],"mappings":"85CAIe,SAASA,EAAT,GAA+C,IAYtDC,EAZqD,IAA1BC,cAA0B,MAAjBC,IAAIC,IAAa,EAALC,EAAK,OACnDC,EAAIJ,EACJK,EAAWF,EAAEE,SACbC,EAAQH,EAAEI,KAEVC,EAAQJ,EAAEA,IAAIK,SAAS,oBAEvBC,EAAc,CAChBC,WAAOC,EACPC,eAAWD,GA+CTE,EAAc,e,EAAA,G,EAAA,yBAAG,WAAMC,GAAN,6FACbC,EAASD,EAAKE,KAAK,QAAQD,OACjCD,EAAKG,KAAK,CAAEC,cAAe,SACtBT,EAAYC,MAHE,uBAIfD,EAAYC,MAAQK,EACpBN,EAAYG,UAAYE,EALT,8BASfL,EAAYC,MATG,oBAUTS,EAAmBhB,EAAEiB,KAAK,EAAG,EAAG,IAAK,KAAKH,KAAK,CAAEI,QAAS,IAC5DZ,EAAYC,QAAUK,EAXX,wBAYXN,EAAYG,UAAUK,KAAK,CAAEC,cAAe,SAC5CJ,EAAKG,KAAK,CAAEC,cAAe,SAErBI,EAAaxB,EAAMyB,OAAM,SAAAC,GAAE,MAAiC,SAA7BA,EAAGP,KAAK,oBAflC,UAgBLQ,YAAK,KAhBA,QAiBPH,GAAYlB,IAjBL,yCAmBLqB,YAAK,KAnBA,QAoBXhB,EAAYG,UAAUN,OACtBQ,EAAKR,OACLG,EAAYG,UAAUK,KAAK,CAAEC,cAAe,SAC5CJ,EAAKG,KAAK,CAAEC,cAAe,SAvBhB,QAyBfT,EAAYC,WAAQC,EACpBF,EAAYG,eAAYD,EACxBQ,EAAiBO,SA3BF,2C,+KAAH,uDA1CC,WACjB,IACQC,EADatB,EAAbuB,SACAD,OACAE,EAAWF,EAAXE,GAAIC,EAAOH,EAAPG,GACNC,EAAeC,YAAgB,EAAG,GAClCC,EAAQC,YAAqB,CAC/BC,WAAY,CAAEC,EAAGP,EAAIQ,EAAGP,GACxBQ,KAAM,EACNC,QAASR,EACTJ,QAAQ,EACRa,IAAK,CAAEJ,EAAG,IAAML,EAAcM,EAAG,OAG/BI,EAAoBC,YAAqB,EAAG,EAAGX,GAC/CY,EAAmBC,YAAQ,GAAD,SAAKH,GAAL,EAA2BA,KAE3D3C,EAAQmC,EAAMY,KAAI,SAACrB,EAAIsB,GACnB,IAAQV,EAASZ,EAATY,EAAGC,EAAMb,EAANa,EACLU,EAASxC,EAAMJ,IAAIK,SAAS,iBAC5BwC,EAAQzC,EAAMJ,IAAIK,SAAS,gBAG7BuC,EAAOE,OAAOb,EAAGC,EAAG,IAAIpB,KAAK,CAAEiC,KAAM,QAIrCF,EAAMC,OAAOb,EAAGC,EAAG,IAAIpB,KAAK,CAAEiC,KAAM,WACpCF,EAAMG,KAAKf,EAAGC,EAAI,IAAWM,EAAiBG,GAAGM,YAAYnC,KAAK,CAC9DoC,WAAY,SACZC,SAAU,KAIlB,IAAMjD,EAAQC,YAAK,CAAEP,OAAQQ,EAAOgD,MAAOR,EAAQS,KAAMR,EAAOS,WAAW,IAK3E,OAJApD,EAAMG,SAAS,gBACfH,EAAMqD,OAAM,kBAAM7C,EAAeR,MAEjCA,EAAMW,KAAK,OAAQ,CAAED,OAAQ4B,EAAiBG,KACvCzC,KAoCXsD,K,o9CC1FD,IAOMC,EAAgB,SAAAC,GAAG,OAAIA,EAAIC,QAAO,SAACtC,EAAIsB,GAAL,OAAWe,EAAIE,QAAQvC,KAAQsB,MACjEkB,EAAe,SAACH,EAAKI,GAC9B,IAAMC,EAAW,GAOjB,OANAL,EAAIM,SAAQ,SAAC3C,EAAIsB,GACb,IAAMsB,EAAIC,KAAKC,MAAMxB,EAAImB,GACnBM,EAAIzB,EAAImB,EACJ,IAANM,IAASL,EAASE,GAAK,IAC3BF,EAASE,GAAGG,GAAK/C,KAEd0C,GAEEM,EAAoB,SAAAX,GAE7B,IADA,IAAMK,EAAW,GADmB,WAE3BpB,GACL,IAAM2B,EAAUZ,EAAIhB,KAAI,SAAArB,GAAE,OAAIA,EAAGsB,MACjCoB,EAASQ,KAAKD,IAFT3B,EAAI,EAAGA,EAAIe,EAAI,GAAGc,OAAQ7B,IAAM,EAAhCA,GAIT,OAAOoB,GAKEhC,EAAuB,SAAC,GAIjC,IAJ2I,IAAD,IAAvGC,kBAAuG,MAA1F,CAAEC,EAAG,EAAGC,EAAG,GAA+E,EAA1EC,EAA0E,EAA1EA,KAAMC,EAAoE,EAApEA,QAAoE,IAA3DC,WAA2D,MAArD,CAAEJ,EAAG,EAAGC,EAAG,GAA0C,MAArCuC,eAAqC,aAApBjD,cAAoB,SACpIM,EAAQ,GACR4C,EAAclD,EAAkB,IAARa,EAAIJ,GAAWG,EAAU,GAAK,EAAtDsC,EAA4DlD,EAAkB,IAARa,EAAIH,GAAWC,EAAO,GAAK,EAE9FQ,EAAI,EAAGA,EAAIR,EAAMQ,IACtB,IAAK,IAAIgC,EAAI,EAAGA,EAAIvC,EAASuC,IAAK,CAC9B,IAAMC,EAAQjC,EAAIP,EAAUuC,EAC5B,EAAe,CAAC3C,EAAWC,EAAII,EAAIJ,EAAI0C,EAAID,EAAU1C,EAAWE,EAAIwC,GAAYD,GAAWpC,EAAIH,EAAIS,EAAIN,EAAIH,EAAIS,IAAxGV,EAAP,KAAUC,EAAV,KACAJ,EAAM8C,GAAS,CAAE3C,IAAGC,KAG5B,OAAOJ,GAEE+C,EAAwB,SAAC,GAgBlC,IAhBwE,IAApCC,EAAmC,EAAnCA,KAAMC,EAA6B,EAA7BA,SAAUC,EAAmB,EAAnBA,aAC9CC,EAAS,GACTC,EAAoB,SAACC,EAAMlD,EAAGC,GAAV,OAAgBgC,KAAKkB,IAAID,EAAKzD,GAAKO,IAAMkD,EAAKE,MAAQ,GAAKnB,KAAKkB,IAAID,EAAKxD,GAAKO,IAAMiD,EAAKG,OAAS,GAYxHxB,EAAI,EAECc,EAAQ,EAAGA,EAAQG,EAAUH,IAElC,IADA,IAAIW,GAAS,EAD8B,aAGvC,IAAM7D,EAAKG,EAAgBiD,EAAK7C,EAAI+C,EAAaK,MAAQ,EAAGP,EAAK7C,EAAI6C,EAAKO,MAAQL,EAAaK,MAAQ,GACjG1D,EAAKE,EAAgBiD,EAAK5C,EAAI8C,EAAaM,OAAS,EAAGR,EAAK5C,EAAI4C,EAAKQ,OAASN,EAAaM,OAAS,GACpGE,EAAc,CAChBvD,EAAGP,EAAKsD,EAAaK,MAAQ,EAC7BI,GAAI/D,EAAKsD,EAAaK,MAAQ,EAC9B3D,KACAQ,EAAGP,EAAKqD,EAAaM,OAAS,EAC9BI,GAAI/D,EAAKqD,EAAaM,OAAS,EAC/B3D,KACA0D,MAAOL,EAAaK,MACpBC,OAAQN,EAAaM,QAEPL,EAAOU,MAAK,SAAAtE,GAAE,OA3BpC6D,EAD4BU,EA4BgCJ,GA5BvCK,EA4BmCxE,GA3BzBY,EAAG4D,EAAM3D,IACxCgD,EAAkBU,EAAOC,EAAMJ,GAAII,EAAM3D,IACzCgD,EAAkBU,EAAOC,EAAM5D,EAAG4D,EAAMH,KACxCR,EAAkBU,EAAOC,EAAMJ,GAAII,EAAMH,KACzCR,EAAkBW,EAAOD,EAAM3D,EAAG2D,EAAM1D,IACxCgD,EAAkBW,EAAOD,EAAMH,GAAIG,EAAM1D,IACzCgD,EAAkBW,EAAOD,EAAM3D,EAAG2D,EAAMF,KACxCR,EAAkBW,EAAOD,EAAMH,GAAIG,EAAMF,IARrB,IAACG,EAAOD,OA8BpBX,EAAOV,KAAKiB,GACZD,GAAS,GAEbzB,GAAK,GAlBFyB,GAAUzB,EALP,KAKmB,IAuBjC,OA5Bc,MA2BVA,GAAagC,QAAQC,MAAM,uBACxBd,GAWE3D,EAAO,eAAC0E,EAAD,uDAAS,IAAT,OAAiB,IAAIC,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAASF,OAGnEI,EAAwB,SAAC1C,EAAKI,GAEvC,IADA,IAAMC,EAAWtB,EAAQiB,GAAK2C,MAAM,EAAGvC,GAChCC,EAASS,OAASV,GACrBC,EAASQ,KAAK9B,EAAQiB,GAAK,IAE/B,OAAOK,GAEElC,EAAkB,SAACyE,EAAKC,GAAN,OAAcrC,KAAKC,MAAMD,KAAKsC,UAAYD,EAAMD,EAAM,IAAMA,GAC9E/D,EAAuB,SAAC+D,EAAKC,EAAKzC,GAAwB,IAArB2C,IAAoB,yDAC9DC,EAAU,GACVC,EAAY,GAChB,GAAIF,EACA,KAAOE,EAAUnC,SAAWV,GAAG,CAC3B,IAAK,IAAIc,EAAQ,EAAGA,EAAQd,EAAGc,IAC3B8B,EAAQ9B,GAAS/C,EAAgByE,EAAKC,GAE1CI,EAAYlD,EAAciD,QAG9B,IAAK,IAAI9B,EAAQ,EAAGA,EAAQd,EAAGc,IAC3B8B,EAAQ9B,GAAS/C,EAAgByE,EAAKC,GAI9C,OAAOG,GAIEE,EAAkC,SAAC,EAAD,GAAyB,IAAD,SAAtBC,EAAsB,KAAlBC,EAAkB,cAAZrB,EAAY,KAARC,EAAQ,KAC7DqB,GAAKrB,EAAKoB,IAAOrB,EAAKoB,GAE5B,MAAO,CAAEE,IAAGC,EADFtB,EAAKqB,EAAItB,IAIVwB,EAAmB,CAC5BC,KAAM,oBAAGL,UAAH,MAAQ,EAAR,MAAWC,UAAX,MAAgB,EAAhB,MAAmBrB,UAAnB,MAAwB,EAAxB,MAA2BC,GAA3B,MAAwC,IAAM,CAACmB,EAAIC,GAAM,KAAO,CAACrB,OAAjE,MAAgC,EAAhC,IACNxE,KAAM,oBAAGgB,SAAH,MAAO,EAAP,MAAUC,SAAV,MAAc,EAAd,MAAiBmD,aAAjB,MAAyB,EAAzB,MAA4BC,cAA5B,MAAqC,EAArC,QAA6C,IAAM,CAACrD,EAAGC,GAAK,KAAO,CAAC,EAAGoD,GAAU,KAAO,CAACD,EAAO,GAAK,KAAO,CAAC,GAAIC,GAAU,KAAO,EAAED,EAAO,IACjJvC,OAAQ,oBAAGpB,UAAH,MAAQ,EAAR,MAAWC,UAAX,MAAgB,EAAhB,MAAmByC,SAAnB,MAAuB,EAAvB,QAA+B,IAAM,CAAC1C,EAAK0C,EAAGzC,EAAKyC,GAAK,IAAM,EAAEA,EAAG,GAAK,IAAM,CAACA,EAAGA,EAAG,EAAG,EAAG,EAAG,EAAO,EAAJA,GAAS,IAAM,CAACA,EAAGA,EAAG,EAAG,EAAG,EAAG,GAAS,EAAJA,IAC7I+C,QAAS,WAAe,IAAD,uBAAVC,EAAU,yBAAVA,EAAU,gBACnB,IAAMC,EAAOC,MAAMC,QAAQH,EAAM,IAAMA,EAAM,GAAKA,EAClD,OAAOC,EAAKG,QAAO,SAACT,EAAGC,EAAGrE,GACtB,OAAU,IAANA,EAAiBoE,GAAKC,EAAI,KACf,IAANrE,EAAiBoE,GAAKC,EAAI,KAC1BrE,EAAI,IAAM,EAAWoE,EAAK,IAAMC,EAAI,IAChCD,GAAKC,EAAI,OACvB,OAIEvE,EAAU,SAAAgF,GAEnB,IADA,IAAMC,EAAYD,EAAM/E,KAAI,SAAArB,GAAE,OAAIA,KACzBsB,EAAI+E,EAAUlD,OAAS,EAAG7B,EAAI,EAAGA,IAAK,CAC3C,IAAMgC,EAAIT,KAAKC,MAAMD,KAAKsC,UAAY7D,EAAI,IACpCgF,EAAID,EAAU/E,GACpB+E,EAAU/E,GAAK+E,EAAU/C,GACzB+C,EAAU/C,GAAKgD,EAEnB,OAAOD,GAWEE,EAAc,SAACb,EAAGC,GAC3B,IAAIlD,EAOJ,OANIiD,EAAEvC,SAAWwC,EAAExC,SACfV,EAAI,EACJiD,EAAE/C,SAAQ,SAAC3C,EAAIsB,GACPtB,IAAO2F,EAAErE,KAAImB,GAAK,OAGvBA,IAAMiD,EAAEvC,QA4BNqD,EAAkB,SAACC,EAAKC,GACjC,IAAIC,EACJ,OAAQD,GACJ,IAAK,IACDC,EAAM,EACNF,EAAI9D,SAAQ,SAAA3C,GACR2G,GAAY3G,KAEhB,MACJ,IAAK,IACDyG,EAAI9D,SAAQ,SAAC3C,EAAIsB,GACbqF,EAAY,IAANrF,EAAUtB,EAAK2G,EAAM3G,KAE/B,MACJ,IAAK,IACD2G,EAAM,EACNF,EAAI9D,SAAQ,SAAA3C,GACR2G,GAAY3G,KAEhB,MACJ,IAAK,KACD2G,EAAM,IACF/D,EAAIC,KAAKC,MAAM2D,EAAI,GAAKA,EAAI,IAChCE,EAAI5D,EAAI0D,EAAI,GAAKA,EAAI,GAG7B,OAAOE","file":"static/js/4.70088a25.chunk.js","sourcesContent":["import { flip } from 'sol-common';\nimport { SOL } from 'sol-common/util';\nimport { getPointInMatrixForm, getRandomNumber, getRandomNumberArray, shuffle, wait } from '../utils/util';\n\nexport default function DM000003({ canvas = SOL.SVG, ...p }) {\n    const g = canvas;\n    const callback = p.callback;\n    const _flip = p.flip;\n\n    const flipG = g.g().addClass('D1-filp-group cp');\n\n    const uswerAnswer = {\n        first: undefined,\n        firstItem: undefined\n    };\n\n    let flips;\n\n    const drawFlipItem = () => {\n        const { position } = _flip;\n        const { center } = position;\n        const { cx, cy } = center;\n        const randomColumn = getRandomNumber(3, 5);\n        const point = getPointInMatrixForm({\n            startPoint: { x: cx, y: cy },\n            rows: 2,\n            columns: randomColumn,\n            center: true,\n            gap: { x: 600 / randomColumn, y: 120 }\n        });\n\n        const randomNumberArray = getRandomNumberArray(1, 9, randomColumn);\n        const shffleCardNumber = shuffle([...randomNumberArray, ...randomNumberArray]);\n\n        flips = point.map((el, i) => {\n            const { x, y } = el;\n            const frontG = flipG.g().addClass('D1-flip-front');\n            const backG = flipG.g().addClass('D1-flip-back');\n\n            {\n                frontG.circle(x, y, 40).attr({ fill: 'red' });\n            }\n\n            {\n                backG.circle(x, y, 40).attr({ fill: 'orange' });\n                backG.text(x, y + 30 * 0.33, shffleCardNumber[i].toString()).attr({\n                    textAnchor: 'middle',\n                    fontSize: 30\n                });\n            }\n\n            const _flip = flip({ canvas: flipG, front: frontG, back: backG, clickable: true });\n            _flip.addClass('D1-flip-item');\n            _flip.click(() => flipEndHandler(_flip));\n\n            _flip.data('data', { number: shffleCardNumber[i] });\n            return _flip;\n        });\n    };\n\n    const flipEndHandler = async self => {\n        const number = self.data('data').number;\n        self.attr({ pointerEvents: 'none' });\n        if (!uswerAnswer.first) {\n            uswerAnswer.first = number;\n            uswerAnswer.firstItem = self;\n            return;\n        }\n\n        if (uswerAnswer.first) {\n            const preventTouchRect = g.rect(0, 0, 800, 500).attr({ opacity: 0 });\n            if (uswerAnswer.first === number) {\n                uswerAnswer.firstItem.attr({ pointerEvents: 'none' });\n                self.attr({ pointerEvents: 'none' });\n\n                const isFrameEnd = flips.every(el => el.attr('pointerEvents') === 'none');\n                await wait(500);\n                if (isFrameEnd) callback();\n            } else {\n                await wait(500);\n                uswerAnswer.firstItem.flip();\n                self.flip();\n                uswerAnswer.firstItem.attr({ pointerEvents: 'auto' });\n                self.attr({ pointerEvents: 'auto' });\n            }\n            uswerAnswer.first = undefined;\n            uswerAnswer.firstItem = undefined;\n            preventTouchRect.remove();\n        }\n    };\n\n    const start = () => {\n        drawFlipItem();\n    };\n\n    start();\n}\n","import Snap from 'sol-common/snap';\n\nexport const getSVGPoint = event => {\n    const svg = document.querySelector('#frame2d');\n    const pt = svg.createSVGPoint();\n    pt.x = event.clientX;\n    pt.y = event.clientY;\n    return pt.matrixTransform(svg.getScreenCTM().inverse());\n};\nexport const getUniquArray = arr => arr.filter((el, i) => arr.indexOf(el) === i);\nexport const get2dimArray = (arr, n) => {\n    const newArray = [];\n    arr.forEach((el, i) => {\n        const q = Math.floor(i / n);\n        const r = i % n;\n        if (r === 0) newArray[q] = [];\n        newArray[q][r] = el;\n    });\n    return newArray;\n};\nexport const getTransposeArray = arr => {\n    const newArray = [];\n    for (let i = 0; i < arr[0].length; i++) {\n        const tempArr = arr.map(el => el[i]);\n        newArray.push(tempArr);\n    }\n    return newArray;\n};\n\nexport const getClassNames = element => element.node.className.baseVal;\n\nexport const getPointInMatrixForm = ({ startPoint = { x: 0, y: 0 }, rows, columns, gap = { x: 0, y: 0 }, reverse = false, center = true }) => {\n    const point = [];\n    const offset = { x: center ? -gap.x * 0.5 * (columns - 1) : 0, y: center ? -gap.y * 0.5 * (rows - 1) : 0 };\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < columns; j++) {\n            const index = i * columns + j;\n            const [x, y] = [startPoint.x + gap.x * j + offset.x, startPoint.y + offset.y + (reverse ? -gap.y * i : gap.y * i)];\n            point[index] = { x, y };\n        }\n    }\n    return point;\n};\nexport const getPointInScatterForm = ({ area, pointNum, neighborhood }) => {\n    const points = [];\n    const isPointInsideBBox = (bbox, x, y) => Math.abs(bbox.cx - x) <= bbox.width / 2 && Math.abs(bbox.cy - y) <= bbox.height / 2;\n    const isBBoxIntersect = (bbox1, bbox2) =>\n        isPointInsideBBox(bbox2, bbox1.x, bbox1.y) ||\n        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) ||\n        isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) ||\n        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) ||\n        isPointInsideBBox(bbox1, bbox2.x, bbox2.y) ||\n        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) ||\n        isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) ||\n        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2);\n\n    const limit = 1000;\n    let n = 0;\n\n    for (let index = 0; index < pointNum; index++) {\n        let repeat = true;\n        while (repeat && n < limit) {\n            const cx = getRandomNumber(area.x + neighborhood.width / 2, area.x + area.width - neighborhood.width / 2);\n            const cy = getRandomNumber(area.y + neighborhood.height / 2, area.y + area.height - neighborhood.height / 2);\n            const boundingBox = {\n                x: cx - neighborhood.width / 2,\n                x2: cx + neighborhood.width / 2,\n                cx,\n                y: cy - neighborhood.height / 2,\n                y2: cy + neighborhood.height / 2,\n                cy,\n                width: neighborhood.width,\n                height: neighborhood.height\n            };\n            const isOverlap = points.some(el => isBBoxIntersect(el, boundingBox));\n            if (!isOverlap) {\n                points.push(boundingBox);\n                repeat = false;\n            }\n            n += 1;\n        }\n    }\n\n    if (n === limit) console.error('CAN NOT GENERATE!!!');\n    return points;\n};\n\nexport const getCloseElement = (targetElement, elements) =>\n    elements.reduce((a, b) => {\n        const currentPoint = targetElement.getBBox().cx;\n        const beforeDx = Math.abs(a.getBBox().cx - currentPoint);\n        const currentDx = Math.abs(b.getBBox().cx - currentPoint);\n        return beforeDx > currentDx ? b : a;\n    }, elements[0]);\n\nexport const wait = (delay = 300) => new Promise(resolve => setTimeout(resolve, delay));\n\nexport const removeArrayElement = (arr, element) => arr.filter(el => el !== element);\nexport const getRandomArrayElement = (arr, n) => {\n    const newArray = shuffle(arr).slice(0, n);\n    while (newArray.length < n) {\n        newArray.push(shuffle(arr)[0]);\n    }\n    return newArray;\n};\nexport const getRandomNumber = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\nexport const getRandomNumberArray = (min, max, n, isUnique = true) => {\n    let randArr = [];\n    let uniqueArr = [];\n    if (isUnique) {\n        while (uniqueArr.length !== n) {\n            for (let index = 0; index < n; index++) {\n                randArr[index] = getRandomNumber(min, max);\n            }\n            uniqueArr = getUniquArray(randArr);\n        }\n    } else {\n        for (let index = 0; index < n; index++) {\n            randArr[index] = getRandomNumber(min, max);\n        }\n    }\n\n    return randArr;\n};\nexport const getSumArray = (arr) => arr.reduce((acc, num) => acc + num);\n\nexport const getSimultaneousEquationConstant = ([x1, y1], [x2, y2]) => {\n    const a = (y2 - y1) / (x2 - x1);\n    const b = y2 - a * x2;\n    return { a, b };\n};\n\nexport const convertToPathStr = {\n    line: ({ x1 = 0, y1 = 0, x2 = 0, y2 = 0 }) => 'M' + [x1, y1] + ' L' + [x2, y2],\n    rect: ({ x = 0, y = 0, width = 0, height = 0 }) => 'M' + [x, y] + ' l' + [0, height] + ' l' + [width, 0] + ' l' + [0, -height] + ' l' + [-width, 0],\n    circle: ({ cx = 0, cy = 0, r = 0 }) => 'M' + [cx + r, cy - r] + 'm' + [-r, 0] + 'a' + [r, r, 0, 1, 1, 0, r * 2] + 'a' + [r, r, 0, 1, 1, 0, -(r * 2)],\n    polygon: (..._rest) => {\n        const rest = Array.isArray(_rest[0]) ? _rest[0] : _rest;\n        return rest.reduce((a, b, i) => {\n            if (i === 0) return (a += b + ',');\n            else if (i === 1) return (a += b + ' ');\n            else if (i % 2 === 0) return (a += 'L' + b + ',');\n            else return (a += b + ' ');\n        }, 'M');\n    }\n};\n\nexport const shuffle = array => {\n    const copyArray = array.map(el => el);\n    for (let i = copyArray.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const k = copyArray[i];\n        copyArray[i] = copyArray[j];\n        copyArray[j] = k;\n    }\n    return copyArray;\n};\n\nexport const makeArrayNumber = ({ startNum = 1, endNum }) => {\n    const rangeNum = [];\n    for (let i = startNum; i < endNum + 1; i++) {\n        rangeNum.push(i);\n    }\n    return rangeNum;\n};\n\nexport const isSameArray = (a, b) => {\n    let n;\n    if (a.length === b.length) {\n        n = 0;\n        a.forEach((el, i) => {\n            if (el === b[i]) n += 1;\n        });\n    }\n    return n === a.length;\n};\n\nexport const saveImage = svg => {\n    const canvas = document.createElement('canvas');\n    canvas.width = 800;\n    canvas.height = 800;\n    const data = new XMLSerializer().serializeToString(svg);\n    const blob = new Blob([data], { type: 'image/svg+xml' });\n    const img = new Image();\n    const url = URL.createObjectURL(blob);\n    img.src = url;\n\n    img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        canvas.getContext('2d')?.drawImage(img, 0, 0);\n        URL.revokeObjectURL(url);\n        const uri = canvas.toDataURL('image/png').replace('image/png', 'octet/stream');\n        console.log(uri);\n        const a = document.createElement('a');\n        a.href = uri;\n        a.download = 'myPhoto.png';\n        a.click();\n        URL.revokeObjectURL(uri);\n    };\n};\n\nexport const calculateAnswer = (num, sign) => {\n    let ans;\n    switch (sign) {\n        case '+':\n            ans = 0;\n            num.forEach(el => {\n                ans = ans + el;\n            });\n            break;\n        case '-':\n            num.forEach((el, i) => {\n                ans = i === 0 ? el : ans + el;\n            });\n            break;\n        case '*':\n            ans = 1;\n            num.forEach(el => {\n                ans = ans * el;\n            });\n            break;\n        case '/':\n            ans = {};\n            ans.q = Math.floor(num[0] / num[1]);\n            ans.r = num[0] % num[1];\n            break;\n    }\n    return ans;\n};\n"],"sourceRoot":""}